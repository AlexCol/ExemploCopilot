# 1.1 - Tipos Nativos Avan√ßados

## üìã O que voc√™ vai aprender

- Tipos num√©ricos especiais (SERIAL, BIGSERIAL)
- UUID e quando utiliz√°-lo
- Tipos de data e hora avan√ßados
- Tipos de rede (INET, CIDR, MACADDR)
- Tipo MONEY e suas peculiaridades
- Tipos booleanos e suas varia√ß√µes

---

## üî¢ Tipos Num√©ricos Especiais

### SERIAL e BIGSERIAL

Tipos auto-incrementais, atalhos para sequences.

```sql
-- SERIAL = INTEGER + SEQUENCE
CREATE TABLE usuarios (
    id SERIAL PRIMARY KEY,  -- Equivalente a INT com sequence
    nome VARCHAR(100)
);

-- BIGSERIAL para valores maiores
CREATE TABLE logs (
    id BIGSERIAL PRIMARY KEY,  -- At√© 9 quintilh√µes
    mensagem TEXT,
    criado_em TIMESTAMP DEFAULT NOW()
);

-- Por baixo dos panos, PostgreSQL cria:
-- CREATE SEQUENCE usuarios_id_seq;
-- CREATE TABLE usuarios (
--     id INTEGER NOT NULL DEFAULT nextval('usuarios_id_seq'),
--     nome VARCHAR(100)
-- );
```

**IDENTITY (PostgreSQL 10+)** - Padr√£o SQL moderno:

```sql
-- Forma moderna e recomendada
CREATE TABLE produtos (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    nome VARCHAR(100)
);

-- Com op√ß√µes
CREATE TABLE pedidos (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1000
        INCREMENT BY 1
        MINVALUE 1000
        MAXVALUE 999999
        CACHE 20
    ) PRIMARY KEY
);
```

**Diferen√ßas**:
- `ALWAYS`: N√£o permite inser√ß√£o manual do ID
- `BY DEFAULT`: Permite override manual

---

## üÜî UUID - Universally Unique Identifier

Identificadores √∫nicos globalmente, ideais para sistemas distribu√≠dos.

```sql
-- Habilitar extens√£o
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Criar tabela com UUID
CREATE TABLE clientes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    nome VARCHAR(100),
    email VARCHAR(100)
);

-- Inserir dados
INSERT INTO clientes (nome, email)
VALUES ('Jo√£o Silva', 'joao@email.com');
-- ID gerado automaticamente: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'

-- Inserir UUID espec√≠fico
INSERT INTO clientes (id, nome, email)
VALUES ('550e8400-e29b-41d4-a716-446655440000', 'Maria', 'maria@email.com');
```

### Quando usar UUID vs SERIAL?

| Aspecto | UUID | SERIAL |
|---------|------|--------|
| **Tamanho** | 16 bytes (128 bits) | 4 bytes (INTEGER) |
| **Performance** | Mais lento para √≠ndices | Mais r√°pido |
| **Sequencial** | Aleat√≥rio | Sequencial |
| **Distribu√≠do** | ‚úÖ Perfeito | ‚ùå Conflitos poss√≠veis |
| **Seguran√ßa** | ‚úÖ N√£o revela quantidade | ‚ùå Previs√≠vel |
| **Uso** | APIs p√∫blicas, microservices | Sistemas monol√≠ticos |

```sql
-- ‚úÖ Use UUID quando:
-- - Sistema distribu√≠do com m√∫ltiplos databases
-- - API p√∫blica (esconde quantidade de registros)
-- - Merge de dados de m√∫ltiplas fontes
-- - Replica√ß√£o multi-master

-- ‚úÖ Use SERIAL quando:
-- - Database centralizado
-- - Performance cr√≠tica
-- - Economia de espa√ßo importante
-- - Ordena√ß√£o por cria√ß√£o importante
```

---

## üìÖ Tipos de Data e Hora

### Tipos Dispon√≠veis

```sql
CREATE TABLE eventos (
    -- DATE: apenas data (4 bytes)
    data_evento DATE,
    
    -- TIME: apenas hora sem timezone (8 bytes)
    hora_inicio TIME,
    
    -- TIME WITH TIME ZONE
    hora_com_fuso TIME WITH TIME ZONE,
    
    -- TIMESTAMP: data + hora sem timezone (8 bytes)
    criado_em TIMESTAMP,
    
    -- TIMESTAMPTZ: data + hora COM timezone (8 bytes) ‚≠ê RECOMENDADO
    atualizado_em TIMESTAMPTZ,
    
    -- INTERVAL: dura√ß√£o/per√≠odo
    duracao INTERVAL
);
```

### Boas Pr√°ticas com Timestamps

```sql
-- ‚úÖ SEMPRE use TIMESTAMPTZ (com timezone)
CREATE TABLE audit_log (
    id SERIAL PRIMARY KEY,
    acao TEXT,
    criado_em TIMESTAMPTZ DEFAULT NOW()  -- Armazena em UTC
);

-- ‚ùå Evite TIMESTAMP sem timezone
-- Pode causar problemas com daylight saving e fuso hor√°rio

-- Inserindo dados
INSERT INTO audit_log (acao) VALUES ('login');
INSERT INTO audit_log (acao, criado_em) 
VALUES ('logout', '2025-11-18 10:30:00-03:00');  -- Especificar timezone

-- Consultas com timezone
SELECT 
    acao,
    criado_em,
    criado_em AT TIME ZONE 'America/Sao_Paulo' AS horario_brasilia,
    criado_em AT TIME ZONE 'UTC' AS horario_utc
FROM audit_log;
```

### Trabalhando com INTERVAL

```sql
-- Opera√ß√µes com intervalos
SELECT 
    NOW() AS agora,
    NOW() + INTERVAL '1 day' AS amanha,
    NOW() - INTERVAL '1 week' AS semana_passada,
    NOW() + INTERVAL '2 hours 30 minutes' AS daqui_a_pouco;

-- Calcular idade
SELECT 
    nome,
    data_nascimento,
    AGE(data_nascimento) AS idade,
    EXTRACT(YEAR FROM AGE(data_nascimento)) AS anos
FROM pessoas;

-- Diferen√ßa entre datas
SELECT 
    pedido_id,
    data_pedido,
    data_entrega,
    data_entrega - data_pedido AS dias_para_entrega,
    AGE(data_entrega, data_pedido) AS tempo_detalhado
FROM pedidos;
```

### Fun√ß√µes √öteis

```sql
-- Data/hora atual
SELECT 
    CURRENT_DATE,           -- Apenas data
    CURRENT_TIME,           -- Apenas hora
    CURRENT_TIMESTAMP,      -- Data + hora
    NOW(),                  -- Igual a CURRENT_TIMESTAMP
    CLOCK_TIMESTAMP(),      -- Hora exata da execu√ß√£o (muda durante transa√ß√£o)
    TRANSACTION_TIMESTAMP(); -- In√≠cio da transa√ß√£o (fixo)

-- Extrair partes
SELECT 
    EXTRACT(YEAR FROM NOW()) AS ano,
    EXTRACT(MONTH FROM NOW()) AS mes,
    EXTRACT(DAY FROM NOW()) AS dia,
    EXTRACT(HOUR FROM NOW()) AS hora,
    EXTRACT(DOW FROM NOW()) AS dia_da_semana, -- 0=domingo
    EXTRACT(EPOCH FROM NOW()) AS unix_timestamp;

-- Formata√ß√£o
SELECT 
    TO_CHAR(NOW(), 'DD/MM/YYYY HH24:MI:SS') AS formato_br,
    TO_CHAR(NOW(), 'YYYY-MM-DD') AS formato_iso,
    TO_CHAR(NOW(), 'Month DD, YYYY') AS formato_extenso;

-- Parsing
SELECT 
    TO_DATE('18/11/2025', 'DD/MM/YYYY') AS data_parseada,
    TO_TIMESTAMP('2025-11-18 10:30:00', 'YYYY-MM-DD HH24:MI:SS') AS timestamp_parseado;
```

---

## üåê Tipos de Rede

Para armazenar endere√ßos IP, ranges de rede e MAC addresses.

```sql
CREATE TABLE dispositivos (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(100),
    -- INET: IPv4 ou IPv6 com ou sem m√°scara
    endereco_ip INET,
    -- CIDR: rede (sem host bits)
    rede CIDR,
    -- MACADDR: endere√ßo MAC
    mac MACADDR
);

-- Inserindo dados
INSERT INTO dispositivos VALUES
(1, 'Servidor Web', '192.168.1.100', '192.168.1.0/24', '08:00:2b:01:02:03'),
(2, 'Firewall', '10.0.0.1/32', '10.0.0.0/8', '08-00-2b-01-02-04'),
(3, 'Roteador', '2001:db8::1', '2001:db8::/32', '08002b:010205');

-- Operadores e fun√ß√µes
SELECT 
    endereco_ip,
    HOST(endereco_ip) AS apenas_ip,
    MASKLEN(endereco_ip) AS tamanho_mascara,
    BROADCAST(rede) AS endereco_broadcast,
    NETWORK(endereco_ip) AS rede_do_ip;

-- Verificar se IP est√° em range
SELECT * FROM dispositivos
WHERE endereco_ip << '192.168.1.0/24';  -- Est√° contido em

SELECT * FROM dispositivos
WHERE '192.168.1.50'::INET << rede;  -- IP est√° na rede?

-- Operadores √∫teis
-- << : est√° contido em
-- <<= : est√° contido ou igual
-- >> : cont√©m
-- >>= : cont√©m ou igual
-- && : overlap (tem interse√ß√£o)
```

### Casos de Uso

```sql
-- Whitelist de IPs
CREATE TABLE acesso_permitido (
    id SERIAL PRIMARY KEY,
    descricao TEXT,
    range_ips CIDR
);

INSERT INTO acesso_permitido VALUES
(1, 'Rede interna', '10.0.0.0/8'),
(2, 'VPN corporativa', '172.16.0.0/12');

-- Verificar acesso
CREATE FUNCTION verificar_acesso(ip INET) RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM acesso_permitido 
        WHERE ip << range_ips
    );
END;
$$ LANGUAGE plpgsql;

SELECT verificar_acesso('10.5.1.100');  -- true
SELECT verificar_acesso('200.1.1.1');   -- false
```

---

## üí∞ Tipo MONEY

Armazena valores monet√°rios com precis√£o fixa.

```sql
CREATE TABLE produtos (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(100),
    preco MONEY
);

-- Inserir valores
INSERT INTO produtos VALUES
(1, 'Notebook', 3500.00),
(2, 'Mouse', 50.50),
(3, 'Teclado', '$125.99');  -- Aceita formato com s√≠mbolo

-- Opera√ß√µes
SELECT 
    nome,
    preco,
    preco * 1.1 AS preco_com_taxa,
    preco::NUMERIC AS valor_numerico,  -- Converter para NUMERIC
    preco::NUMERIC::TEXT AS valor_texto;

-- Agrega√ß√µes
SELECT 
    SUM(preco) AS total,
    AVG(preco) AS media,
    MIN(preco) AS mais_barato,
    MAX(preco) AS mais_caro
FROM produtos;
```

### ‚ö†Ô∏è Cuidados com MONEY

```sql
-- ‚ùå PROBLEMA: Depende de configura√ß√£o de locale
SET lc_monetary = 'en_US.UTF-8';
SELECT '100.00'::MONEY;  -- $100.00

SET lc_monetary = 'pt_BR.UTF-8';
SELECT '100.00'::MONEY;  -- R$ 100,00

-- ‚úÖ SOLU√á√ÉO: Use NUMERIC para valores monet√°rios em produ√ß√£o
CREATE TABLE produtos_correto (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(100),
    preco NUMERIC(10, 2),  -- 10 d√≠gitos, 2 decimais
    moeda CHAR(3) DEFAULT 'BRL'
);
```

**Recomenda√ß√£o**: Para aplica√ß√µes multi-moeda ou internacionais, prefira `NUMERIC` ou `DECIMAL` com coluna separada para moeda.

---

## ‚úÖ Tipo BOOLEAN

```sql
CREATE TABLE tarefas (
    id SERIAL PRIMARY KEY,
    titulo TEXT,
    concluida BOOLEAN DEFAULT FALSE,
    ativo BOOLEAN DEFAULT TRUE
);

-- Inserir booleanos
INSERT INTO tarefas (titulo, concluida) VALUES
('Tarefa 1', TRUE),
('Tarefa 2', FALSE),
('Tarefa 3', 't'),      -- Aceita 't', 'true', 'y', 'yes', '1'
('Tarefa 4', 'n'),      -- Aceita 'f', 'false', 'n', 'no', '0'
('Tarefa 5', NULL);     -- NULL √© diferente de FALSE

-- Consultas
SELECT * FROM tarefas WHERE concluida;  -- concluida = TRUE
SELECT * FROM tarefas WHERE NOT concluida;  -- concluida = FALSE
SELECT * FROM tarefas WHERE concluida IS NULL;

-- Opera√ß√µes l√≥gicas
SELECT 
    titulo,
    concluida,
    ativo,
    concluida AND ativo AS pode_arquivar,
    concluida OR ativo AS visivel,
    NOT concluida AS pendente
FROM tarefas;
```

---

## üéì Resumo e Boas Pr√°ticas

| Tipo | Quando Usar | Evitar |
|------|-------------|--------|
| **SERIAL/BIGSERIAL** | IDs em sistema √∫nico | Sistemas distribu√≠dos |
| **UUID** | APIs, microservices, distribu√≠do | Quando performance de √≠ndice √© cr√≠tica |
| **TIMESTAMPTZ** | ‚≠ê SEMPRE para timestamps | TIMESTAMP sem TZ |
| **INET/CIDR** | Endere√ßos IP, ranges de rede | Armazenar como TEXT |
| **NUMERIC** | Valores monet√°rios precisos | MONEY para produ√ß√£o |
| **BOOLEAN** | Flags, estados bin√°rios | Usar INT (0/1) |

---

## üîó Navega√ß√£o

‚¨ÖÔ∏è [Voltar ao √çndice](../README.md) | [Pr√≥ximo: JSONB e Dados Semi-Estruturados ‚Üí](./02-jsonb-dados-semi-estruturados.md)

---

## üìù Exerc√≠cio R√°pido

Antes de avan√ßar, crie esta tabela e insira alguns dados:

```sql
CREATE TABLE sistema_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    timestamp_evento TIMESTAMPTZ DEFAULT NOW(),
    ip_origem INET,
    usuario_id INTEGER,
    ativo BOOLEAN DEFAULT TRUE
);

INSERT INTO sistema_logs (ip_origem, usuario_id) VALUES
('192.168.1.100', 1),
('10.0.0.50', 2),
('2001:db8::1', 3);

SELECT * FROM sistema_logs;
```

üìö **Exerc√≠cios completos no final do m√≥dulo**: [Exerc√≠cios](./exercicios.md)
