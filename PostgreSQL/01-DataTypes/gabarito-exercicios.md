# Gabarito dos Exerc√≠cios - Data Types

## ‚úÖ Solu√ß√µes Comentadas

---

## Exerc√≠cio 1: SERIAL vs UUID

```sql
-- a) Criar tabela com SERIAL
CREATE TABLE clientes_serial (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(100),
    email VARCHAR(100)
);

-- b) Criar tabela com UUID
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE clientes_uuid (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    nome VARCHAR(100),
    email VARCHAR(100)
);

-- c) Inserir 3 clientes em cada
INSERT INTO clientes_serial (nome, email) VALUES
('Jo√£o Silva', 'joao@email.com'),
('Maria Santos', 'maria@email.com'),
('Pedro Oliveira', 'pedro@email.com');

INSERT INTO clientes_uuid (nome, email) VALUES
('Jo√£o Silva', 'joao@email.com'),
('Maria Santos', 'maria@email.com'),
('Pedro Oliveira', 'pedro@email.com');

-- d) Consultar e comparar
SELECT 'SERIAL' as tipo, id, nome FROM clientes_serial
UNION ALL
SELECT 'UUID' as tipo, id::TEXT, nome FROM clientes_uuid
ORDER BY tipo, nome;

/*
OBSERVA√á√ïES:
- SERIAL: IDs sequenciais (1, 2, 3)
- UUID: IDs √∫nicos globalmente (ex: a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11)
- SERIAL √© menor (4 bytes) vs UUID (16 bytes)
- UUID √© ideal para sistemas distribu√≠dos
*/
```

---

## Exerc√≠cio 2: IDENTITY

```sql
-- Tabela com GENERATED ALWAYS
CREATE TABLE produtos_always (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    nome VARCHAR(100)
);

-- Tentar inserir com ID manual - ERRO!
INSERT INTO produtos_always (id, nome) VALUES (100, 'Produto A');
-- ERROR: cannot insert into column "id"

-- Inserir corretamente (sem especificar ID)
INSERT INTO produtos_always (nome) VALUES ('Produto A');

-- For√ßar override (se realmente necess√°rio)
INSERT INTO produtos_always (id, nome) OVERRIDING SYSTEM VALUE VALUES (100, 'Produto B');

-- ============================================

-- Tabela com GENERATED BY DEFAULT
CREATE TABLE produtos_default (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome VARCHAR(100)
);

-- Inserir sem ID - gera automaticamente
INSERT INTO produtos_default (nome) VALUES ('Produto C');

-- Inserir COM ID manual - funciona!
INSERT INTO produtos_default (id, nome) VALUES (1000, 'Produto D');

-- Verificar
SELECT * FROM produtos_default ORDER BY id;

/*
RESULTADO ESPERADO:
id   | nome
-----|----------
1    | Produto C
1000 | Produto D

CONCLUS√ÉO:
- ALWAYS: Mais restritivo, for√ßa uso da sequence
- BY DEFAULT: Flex√≠vel, permite override manual
*/
```

---

## Exerc√≠cio 3: Timestamps com Timezone

```sql
-- Criar tabela
CREATE TABLE eventos_globais (
    id SERIAL PRIMARY KEY,
    descricao TEXT,
    timestamp_evento TIMESTAMPTZ
);

-- Inserir eventos em diferentes timezones
INSERT INTO eventos_globais (descricao, timestamp_evento) VALUES
('Confer√™ncia Nova York', '2025-11-18 10:00:00-05'),
('Lan√ßamento T√≥quio', '2025-11-18 23:00:00+09'),
('Reuni√£o Londres', '2025-11-18 15:00:00+00');

-- Consultar convertendo para hor√°rio de Bras√≠lia
SELECT 
    descricao,
    timestamp_evento AS utc,
    timestamp_evento AT TIME ZONE 'America/Sao_Paulo' AS horario_brasilia,
    timestamp_evento AT TIME ZONE 'America/New_York' AS horario_ny,
    timestamp_evento AT TIME ZONE 'Asia/Tokyo' AS horario_tokyo
FROM eventos_globais
ORDER BY timestamp_evento;

/*
IMPORTANTE:
- PostgreSQL armazena TIMESTAMPTZ sempre em UTC internamente
- A convers√£o para timezone √© feita na apresenta√ß√£o
- Todos os eventos s√£o compar√°veis independente do timezone de origem
*/

-- Verificar timezone atual do servidor
SHOW timezone;

-- Listar todos os timezones dispon√≠veis
SELECT name FROM pg_timezone_names WHERE name LIKE '%Sao%';
```

---

## Exerc√≠cio 4: Opera√ß√µes com Datas

```sql
-- Usando a tabela do exerc√≠cio anterior

-- a) Dias desde cada evento at√© hoje
SELECT 
    descricao,
    timestamp_evento,
    CURRENT_DATE - timestamp_evento::DATE AS dias_passados,
    AGE(NOW(), timestamp_evento) AS tempo_passado_detalhado
FROM eventos_globais;

-- b) Eventos da √∫ltima semana
SELECT descricao, timestamp_evento
FROM eventos_globais
WHERE timestamp_evento >= NOW() - INTERVAL '7 days'
ORDER BY timestamp_evento DESC;

-- c) Dia da semana de cada evento
SELECT 
    descricao,
    timestamp_evento,
    TO_CHAR(timestamp_evento, 'Day') AS dia_semana_ingles,
    TO_CHAR(timestamp_evento, 'TMDay') AS dia_semana_locale,
    CASE EXTRACT(DOW FROM timestamp_evento)
        WHEN 0 THEN 'Domingo'
        WHEN 1 THEN 'Segunda-feira'
        WHEN 2 THEN 'Ter√ßa-feira'
        WHEN 3 THEN 'Quarta-feira'
        WHEN 4 THEN 'Quinta-feira'
        WHEN 5 THEN 'Sexta-feira'
        WHEN 6 THEN 'S√°bado'
    END AS dia_semana_pt
FROM eventos_globais;

-- d) Diferen√ßa em horas entre primeiro e √∫ltimo evento
SELECT 
    MIN(timestamp_evento) AS primeiro_evento,
    MAX(timestamp_evento) AS ultimo_evento,
    EXTRACT(EPOCH FROM (MAX(timestamp_evento) - MIN(timestamp_evento)))/3600 AS diferenca_horas
FROM eventos_globais;
```

---

## Exerc√≠cio 5: INTERVAL

```sql
-- Criar tabela
CREATE TABLE tarefas (
    id SERIAL PRIMARY KEY,
    titulo TEXT,
    prazo TIMESTAMPTZ,
    tempo_estimado INTERVAL
);

-- a) Inserir 5 tarefas
INSERT INTO tarefas (titulo, prazo, tempo_estimado) VALUES
('Desenvolver API', NOW() + INTERVAL '7 days', INTERVAL '3 days'),
('Code Review', NOW() + INTERVAL '2 days', INTERVAL '4 hours'),
('Documenta√ß√£o', NOW() + INTERVAL '5 days', INTERVAL '1 day'),
('Testes', NOW() + INTERVAL '10 days', INTERVAL '2 days'),
('Deploy', NOW() + INTERVAL '14 days', INTERVAL '2 hours');

-- b) Calcular data de in√≠cio necess√°ria
SELECT 
    titulo,
    prazo,
    tempo_estimado,
    prazo - tempo_estimado AS deve_iniciar_em,
    CASE 
        WHEN (prazo - tempo_estimado) <= NOW() THEN '‚ö†Ô∏è  ATRASADO'
        WHEN (prazo - tempo_estimado) <= NOW() + INTERVAL '1 day' THEN 'üîî URGENTE'
        ELSE '‚úÖ OK'
    END AS status
FROM tarefas
ORDER BY deve_iniciar_em;

-- c) Tarefas que precisam come√ßar hoje ou j√° deveriam ter come√ßado
SELECT 
    titulo,
    prazo - tempo_estimado AS deve_iniciar_em
FROM tarefas
WHERE (prazo - tempo_estimado) <= NOW() + INTERVAL '1 day'
ORDER BY deve_iniciar_em;

-- d) Tempo total estimado
SELECT 
    SUM(tempo_estimado) AS tempo_total,
    EXTRACT(EPOCH FROM SUM(tempo_estimado))/3600 AS total_horas,
    EXTRACT(EPOCH FROM SUM(tempo_estimado))/86400 AS total_dias
FROM tarefas;
```

---

## Exerc√≠cio 6: Tipos de Rede - Whitelist

```sql
-- a) Criar tabela whitelist
CREATE TABLE whitelist (
    id SERIAL PRIMARY KEY,
    descricao TEXT,
    range_ips CIDR
);

-- b) Inserir ranges
INSERT INTO whitelist (descricao, range_ips) VALUES
('Rede Interna', '10.0.0.0/8'),
('VPN Corporativa', '172.16.0.0/12'),
('Escrit√≥rio Principal', '192.168.1.0/24');

-- c) Criar fun√ß√£o de verifica√ß√£o
CREATE OR REPLACE FUNCTION verificar_acesso(ip_cliente INET) 
RETURNS TABLE(tem_acesso BOOLEAN, descricao TEXT) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        TRUE AS tem_acesso,
        w.descricao
    FROM whitelist w
    WHERE ip_cliente << w.range_ips
    LIMIT 1;
    
    -- Se n√£o encontrou nada, retornar FALSE
    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, 'Acesso Negado'::TEXT;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- d) Testar IPs
SELECT * FROM verificar_acesso('10.5.1.100'::INET);      -- TRUE (rede interna)
SELECT * FROM verificar_acesso('192.168.1.50'::INET);    -- TRUE (escrit√≥rio)
SELECT * FROM verificar_acesso('200.1.1.1'::INET);       -- FALSE (n√£o autorizado)
SELECT * FROM verificar_acesso('172.16.10.25'::INET);    -- TRUE (VPN)

-- Verifica√ß√£o alternativa sem fun√ß√£o
SELECT 
    '10.5.1.100'::INET AS ip,
    CASE 
        WHEN EXISTS(SELECT 1 FROM whitelist WHERE '10.5.1.100'::INET << range_ips)
        THEN 'PERMITIDO ‚úÖ'
        ELSE 'BLOQUEADO ‚ùå'
    END AS status;
```

---

## Exerc√≠cio 7: Operadores de Rede

```sql
-- Setup (j√° fornecido no exerc√≠cio)
CREATE TABLE dispositivos (
    id SERIAL PRIMARY KEY,
    nome TEXT,
    ip INET,
    rede CIDR
);

INSERT INTO dispositivos VALUES
(1, 'Servidor Web', '192.168.1.100', '192.168.1.0/24'),
(2, 'Servidor DB', '192.168.1.200', '192.168.1.0/24'),
(3, 'Firewall', '10.0.0.1', '10.0.0.0/8'),
(4, 'Roteador Principal', '172.16.0.1', '172.16.0.0/12');

-- a) Dispositivos cuja rede cont√©m IP 192.168.1.150
SELECT nome, rede
FROM dispositivos
WHERE '192.168.1.150'::INET << rede;

-- b) Dispositivos na mesma sub-rede que 192.168.1.100
SELECT d1.nome AS dispositivo, d2.nome AS mesmo_subnet_que
FROM dispositivos d1
CROSS JOIN dispositivos d2
WHERE d1.id != d2.id
  AND d1.rede = d2.rede
  AND d2.nome = 'Servidor Web';

-- Alternativa mais simples
SELECT nome, rede
FROM dispositivos
WHERE rede = (SELECT rede FROM dispositivos WHERE ip = '192.168.1.100');

-- c) Endere√ßo de broadcast de cada rede
SELECT 
    nome,
    rede,
    BROADCAST(rede) AS endereco_broadcast,
    NETWORK(rede) AS endereco_rede,
    MASKLEN(rede) AS mascara
FROM dispositivos;

-- d) Verificar overlap entre redes
SELECT 
    '192.168.1.0/24'::CIDR && '192.168.2.0/24'::CIDR AS tem_overlap_1,
    '192.168.1.0/24'::CIDR && '192.168.1.0/25'::CIDR AS tem_overlap_2,
    '10.0.0.0/8'::CIDR && '172.16.0.0/12'::CIDR AS tem_overlap_3;

/*
RESULTADO:
tem_overlap_1 | tem_overlap_2 | tem_overlap_3
--------------|---------------|---------------
false         | true          | false

EXPLICA√á√ÉO:
- && retorna TRUE se as redes t√™m interse√ß√£o
- 192.168.1.0/24 e 192.168.2.0/24 s√£o redes diferentes
- 192.168.1.0/25 est√° contida em 192.168.1.0/24
*/
```

---

## Exerc√≠cio 8: MONEY vs NUMERIC

```sql
-- a) Criar tabelas
CREATE TABLE vendas_money (
    id SERIAL PRIMARY KEY,
    produto VARCHAR(100),
    preco MONEY
);

CREATE TABLE vendas_numeric (
    id SERIAL PRIMARY KEY,
    produto VARCHAR(100),
    preco NUMERIC(10, 2)
);

-- b) Inserir mesmos produtos
INSERT INTO vendas_money (produto, preco) VALUES
('Notebook', 3500.00),
('Mouse', 50.50),
('Teclado', 125.99),
('Monitor', 890.00),
('Webcam', 245.50);

INSERT INTO vendas_numeric (produto, preco) VALUES
('Notebook', 3500.00),
('Mouse', 50.50),
('Teclado', 125.99),
('Monitor', 890.00),
('Webcam', 245.50);

-- c) Calcular desconto de 15%
SELECT 
    produto,
    preco AS preco_original,
    preco * 0.85 AS preco_com_desconto
FROM vendas_money;

SELECT 
    produto,
    preco AS preco_original,
    ROUND(preco * 0.85, 2) AS preco_com_desconto
FROM vendas_numeric;

-- d) Convers√µes
SELECT 
    produto,
    preco AS money_original,
    preco::NUMERIC AS convertido_para_numeric,
    preco::NUMERIC::TEXT AS como_texto
FROM vendas_money;

SELECT 
    produto,
    preco AS numeric_original,
    preco::MONEY AS convertido_para_money
FROM vendas_numeric;

-- e) Teste de performance (opcional)
-- Inserir 10.000 registros
DO $$
BEGIN
    FOR i IN 1..10000 LOOP
        INSERT INTO vendas_money (produto, preco) 
        VALUES ('Produto ' || i, (random() * 1000)::NUMERIC);
        
        INSERT INTO vendas_numeric (produto, preco) 
        VALUES ('Produto ' || i, ROUND((random() * 1000)::NUMERIC, 2));
    END LOOP;
END $$;

-- Comparar tamanho
SELECT 
    'vendas_money' AS tabela,
    pg_size_pretty(pg_total_relation_size('vendas_money')) AS tamanho
UNION ALL
SELECT 
    'vendas_numeric',
    pg_size_pretty(pg_total_relation_size('vendas_numeric'));

/*
CONCLUS√ïES:
- MONEY √© mais compacto mas depende de locale
- NUMERIC √© mais port√°vel e preciso
- Para produ√ß√£o, prefira NUMERIC para valores monet√°rios
*/
```

---

## üéØ Exerc√≠cios 9-20: Estrutura de Solu√ß√£o

Devido ao tamanho, aqui est√£o as solu√ß√µes principais dos exerc√≠cios restantes:

### Exerc√≠cio 9: BOOLEAN - Sistema de Tarefas

```sql
CREATE TABLE tarefas_projeto (
    id SERIAL PRIMARY KEY,
    titulo TEXT,
    concluida BOOLEAN DEFAULT FALSE,
    urgente BOOLEAN DEFAULT FALSE,
    aprovada BOOLEAN DEFAULT NULL,
    arquivada BOOLEAN DEFAULT FALSE
);

INSERT INTO tarefas_projeto (titulo, concluida, urgente, aprovada, arquivada) VALUES
('Implementar login', FALSE, TRUE, NULL, FALSE),
('Corrigir bug cr√≠tico', FALSE, TRUE, TRUE, FALSE),
('Refatorar c√≥digo', FALSE, FALSE, NULL, FALSE),
('Atualizar docs', TRUE, FALSE, FALSE, FALSE),
('Code review', TRUE, FALSE, TRUE, FALSE),
('Deploy produ√ß√£o', FALSE, TRUE, FALSE, FALSE),
('Testes unit√°rios', TRUE, TRUE, TRUE, FALSE),
('Reuni√£o cliente', TRUE, FALSE, TRUE, TRUE),
('Backup database', FALSE, FALSE, TRUE, FALSE),
('An√°lise performance', FALSE, FALSE, NULL, FALSE);

-- b) Tarefas pendentes
SELECT * FROM tarefas_projeto
WHERE NOT concluida AND NOT arquivada;

-- c) Tarefas urgentes aguardando aprova√ß√£o
SELECT * FROM tarefas_projeto
WHERE urgente AND aprovada IS NULL;

-- d) Tarefas conclu√≠das mas n√£o aprovadas
SELECT * FROM tarefas_projeto
WHERE concluida AND aprovada = FALSE;

-- e) View de classifica√ß√£o
CREATE VIEW vw_status_tarefas AS
SELECT 
    id,
    titulo,
    CASE
        WHEN arquivada THEN 'üì¶ Arquivada'
        WHEN concluida AND aprovada THEN '‚úÖ Conclu√≠da e Aprovada'
        WHEN concluida AND NOT COALESCE(aprovada, TRUE) THEN '‚ö†Ô∏è  Conclu√≠da mas Reprovada'
        WHEN concluida AND aprovada IS NULL THEN 'üîÑ Aguardando Aprova√ß√£o'
        WHEN urgente AND NOT concluida THEN 'üö® Urgente'
        ELSE 'üìã Pendente'
    END AS status
FROM tarefas_projeto;

SELECT * FROM vw_status_tarefas;
```

### Exerc√≠cio 10: UUID em Sistemas Distribu√≠dos

```sql
CREATE TABLE pedidos (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    servidor_origem VARCHAR(20),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    valor NUMERIC(10,2)
);

-- Simular 3 servidores inserindo simultaneamente
-- (em produ√ß√£o, seriam conex√µes diferentes)
INSERT INTO pedidos (servidor_origem, valor) VALUES ('Servidor-A', 100.00);
INSERT INTO pedidos (servidor_origem, valor) VALUES ('Servidor-B', 150.00);
INSERT INTO pedidos (servidor_origem, valor) VALUES ('Servidor-C', 200.00);
INSERT INTO pedidos (servidor_origem, valor) VALUES ('Servidor-A', 120.00);
INSERT INTO pedidos (servidor_origem, valor) VALUES ('Servidor-B', 175.00);

-- Verificar: todos os IDs s√£o √∫nicos!
SELECT id, servidor_origem, valor FROM pedidos;

-- Compara√ß√£o com SERIAL (problema)
CREATE TABLE pedidos_serial (
    id SERIAL PRIMARY KEY,
    servidor_origem VARCHAR(20),
    valor NUMERIC(10,2)
);

-- Se 3 servidores gerarem IDs localmente, haver√° conflito ao mesclar!
-- Com UUID, n√£o h√° conflito mesmo em sistemas totalmente distribu√≠dos
```

---

## üìä Dicas para Exerc√≠cios Restantes

**Exerc√≠cio 11-13**: Use `TO_CHAR` para formata√ß√£o de datas  
**Exerc√≠cio 14**: Use `CREATE DOMAIN` com constraints  
**Exerc√≠cio 15**: IPv6 usa mesmos operadores que IPv4  
**Exerc√≠cio 16**: Use `EXPLAIN ANALYZE` e `pg_total_relation_size()`  
**Exerc√≠cio 17**: Combine `EXTRACT`, `AGE` e `INTERVAL`  
**Exerc√≠cio 18**: Use `TRY...CATCH` em PL/pgSQL para migra√ß√£o segura  
**Exerc√≠cio 19-20**: Combine todos os conceitos aprendidos  

---

## üîó Navega√ß√£o

[‚Üê Voltar para Exerc√≠cios](./exercicios.md) | [Pr√≥ximo T√≥pico: JSONB ‚Üí](./02-jsonb-dados-semi-estruturados.md)
