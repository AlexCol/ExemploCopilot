# Gabarito dos Exerc√≠cios - Data Types

## ‚úÖ Solu√ß√µes Comentadas

---

## Exerc√≠cio 1: SERIAL vs UUID

```sql
-- a) Criar tabela com SERIAL
CREATE TABLE clientes_serial (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(100),
    email VARCHAR(100)
);

-- b) Criar tabela com UUID
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE clientes_uuid (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    nome VARCHAR(100),
    email VARCHAR(100)
);

-- c) Inserir 3 clientes em cada
INSERT INTO clientes_serial (nome, email) VALUES
('Jo√£o Silva', 'joao@email.com'),
('Maria Santos', 'maria@email.com'),
('Pedro Oliveira', 'pedro@email.com');

INSERT INTO clientes_uuid (nome, email) VALUES
('Jo√£o Silva', 'joao@email.com'),
('Maria Santos', 'maria@email.com'),
('Pedro Oliveira', 'pedro@email.com');

-- d) Consultar e comparar
SELECT 'SERIAL' as tipo, id, nome FROM clientes_serial
UNION ALL
SELECT 'UUID' as tipo, id::TEXT, nome FROM clientes_uuid
ORDER BY tipo, nome;

/*
OBSERVA√á√ïES:
- SERIAL: IDs sequenciais (1, 2, 3)
- UUID: IDs √∫nicos globalmente (ex: a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11)
- SERIAL √© menor (4 bytes) vs UUID (16 bytes)
- UUID √© ideal para sistemas distribu√≠dos
*/
```

---

## Exerc√≠cio 2: IDENTITY

```sql
-- Tabela com GENERATED ALWAYS
CREATE TABLE produtos_always (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    nome VARCHAR(100)
);

-- Tentar inserir com ID manual - ERRO!
INSERT INTO produtos_always (id, nome) VALUES (100, 'Produto A');
-- ERROR: cannot insert into column "id"

-- Inserir corretamente (sem especificar ID)
INSERT INTO produtos_always (nome) VALUES ('Produto A');

-- For√ßar override (se realmente necess√°rio)
INSERT INTO produtos_always (id, nome) OVERRIDING SYSTEM VALUE VALUES (100, 'Produto B');

-- ============================================

-- Tabela com GENERATED BY DEFAULT
CREATE TABLE produtos_default (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome VARCHAR(100)
);

-- Inserir sem ID - gera automaticamente
INSERT INTO produtos_default (nome) VALUES ('Produto C');

-- Inserir COM ID manual - funciona!
INSERT INTO produtos_default (id, nome) VALUES (1000, 'Produto D');

-- Verificar
SELECT * FROM produtos_default ORDER BY id;

/*
RESULTADO ESPERADO:
id   | nome
-----|----------
1    | Produto C
1000 | Produto D

CONCLUS√ÉO:
- ALWAYS: Mais restritivo, for√ßa uso da sequence
- BY DEFAULT: Flex√≠vel, permite override manual
*/
```

---

## Exerc√≠cio 3: Timestamps com Timezone

```sql
-- Criar tabela
CREATE TABLE eventos_globais (
    id SERIAL PRIMARY KEY,
    descricao TEXT,
    timestamp_evento TIMESTAMPTZ
);

-- Inserir eventos em diferentes timezones
INSERT INTO eventos_globais (descricao, timestamp_evento) VALUES
('Confer√™ncia Nova York', '2025-11-18 10:00:00-05'),
('Lan√ßamento T√≥quio', '2025-11-18 23:00:00+09'),
('Reuni√£o Londres', '2025-11-18 15:00:00+00');

-- Consultar convertendo para hor√°rio de Bras√≠lia
SELECT 
    descricao,
    timestamp_evento AS utc,
    timestamp_evento AT TIME ZONE 'America/Sao_Paulo' AS horario_brasilia,
    timestamp_evento AT TIME ZONE 'America/New_York' AS horario_ny,
    timestamp_evento AT TIME ZONE 'Asia/Tokyo' AS horario_tokyo
FROM eventos_globais
ORDER BY timestamp_evento;

/*
IMPORTANTE:
- PostgreSQL armazena TIMESTAMPTZ sempre em UTC internamente
- A convers√£o para timezone √© feita na apresenta√ß√£o
- Todos os eventos s√£o compar√°veis independente do timezone de origem
*/

-- Verificar timezone atual do servidor
SHOW timezone;

-- Listar todos os timezones dispon√≠veis
SELECT name FROM pg_timezone_names WHERE name LIKE '%Sao%';
```

---

## Exerc√≠cio 4: Opera√ß√µes com Datas

```sql
-- Usando a tabela do exerc√≠cio anterior

-- a) Dias desde cada evento at√© hoje
SELECT 
    descricao,
    timestamp_evento,
    CURRENT_DATE - timestamp_evento::DATE AS dias_passados,
    AGE(NOW(), timestamp_evento) AS tempo_passado_detalhado
FROM eventos_globais;

-- b) Eventos da √∫ltima semana
SELECT descricao, timestamp_evento
FROM eventos_globais
WHERE timestamp_evento >= NOW() - INTERVAL '7 days'
ORDER BY timestamp_evento DESC;

-- c) Dia da semana de cada evento
SELECT 
    descricao,
    timestamp_evento,
    TO_CHAR(timestamp_evento, 'Day') AS dia_semana_ingles,
    TO_CHAR(timestamp_evento, 'TMDay') AS dia_semana_locale,
    CASE EXTRACT(DOW FROM timestamp_evento)
        WHEN 0 THEN 'Domingo'
        WHEN 1 THEN 'Segunda-feira'
        WHEN 2 THEN 'Ter√ßa-feira'
        WHEN 3 THEN 'Quarta-feira'
        WHEN 4 THEN 'Quinta-feira'
        WHEN 5 THEN 'Sexta-feira'
        WHEN 6 THEN 'S√°bado'
    END AS dia_semana_pt
FROM eventos_globais;

-- d) Diferen√ßa em horas entre primeiro e √∫ltimo evento
SELECT 
    MIN(timestamp_evento) AS primeiro_evento,
    MAX(timestamp_evento) AS ultimo_evento,
    EXTRACT(EPOCH FROM (MAX(timestamp_evento) - MIN(timestamp_evento)))/3600 AS diferenca_horas
FROM eventos_globais;
```

---

## Exerc√≠cio 5: INTERVAL

```sql
-- Criar tabela
CREATE TABLE tarefas (
    id SERIAL PRIMARY KEY,
    titulo TEXT,
    prazo TIMESTAMPTZ,
    tempo_estimado INTERVAL
);

-- a) Inserir 5 tarefas
INSERT INTO tarefas (titulo, prazo, tempo_estimado) VALUES
('Desenvolver API', NOW() + INTERVAL '7 days', INTERVAL '3 days'),
('Code Review', NOW() + INTERVAL '2 days', INTERVAL '4 hours'),
('Documenta√ß√£o', NOW() + INTERVAL '5 days', INTERVAL '1 day'),
('Testes', NOW() + INTERVAL '10 days', INTERVAL '2 days'),
('Deploy', NOW() + INTERVAL '14 days', INTERVAL '2 hours');

-- b) Calcular data de in√≠cio necess√°ria
SELECT 
    titulo,
    prazo,
    tempo_estimado,
    prazo - tempo_estimado AS deve_iniciar_em,
    CASE 
        WHEN (prazo - tempo_estimado) <= NOW() THEN '‚ö†Ô∏è  ATRASADO'
        WHEN (prazo - tempo_estimado) <= NOW() + INTERVAL '1 day' THEN 'üîî URGENTE'
        ELSE '‚úÖ OK'
    END AS status
FROM tarefas
ORDER BY deve_iniciar_em;

-- c) Tarefas que precisam come√ßar hoje ou j√° deveriam ter come√ßado
SELECT 
    titulo,
    prazo - tempo_estimado AS deve_iniciar_em
FROM tarefas
WHERE (prazo - tempo_estimado) <= NOW() + INTERVAL '1 day'
ORDER BY deve_iniciar_em;

-- d) Tempo total estimado
SELECT 
    SUM(tempo_estimado) AS tempo_total,
    EXTRACT(EPOCH FROM SUM(tempo_estimado))/3600 AS total_horas,
    EXTRACT(EPOCH FROM SUM(tempo_estimado))/86400 AS total_dias
FROM tarefas;
```

---

## Exerc√≠cio 6: Tipos de Rede - Whitelist

```sql
-- a) Criar tabela whitelist
CREATE TABLE whitelist (
    id SERIAL PRIMARY KEY,
    descricao TEXT,
    range_ips CIDR
);

-- b) Inserir ranges
INSERT INTO whitelist (descricao, range_ips) VALUES
('Rede Interna', '10.0.0.0/8'),
('VPN Corporativa', '172.16.0.0/12'),
('Escrit√≥rio Principal', '192.168.1.0/24');

-- c) Criar fun√ß√£o de verifica√ß√£o
CREATE OR REPLACE FUNCTION verificar_acesso(ip_cliente INET) 
RETURNS TABLE(tem_acesso BOOLEAN, descricao TEXT) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        TRUE AS tem_acesso,
        w.descricao
    FROM whitelist w
    WHERE ip_cliente << w.range_ips
    LIMIT 1;
    
    -- Se n√£o encontrou nada, retornar FALSE
    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, 'Acesso Negado'::TEXT;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- d) Testar IPs
SELECT * FROM verificar_acesso('10.5.1.100'::INET);      -- TRUE (rede interna)
SELECT * FROM verificar_acesso('192.168.1.50'::INET);    -- TRUE (escrit√≥rio)
SELECT * FROM verificar_acesso('200.1.1.1'::INET);       -- FALSE (n√£o autorizado)
SELECT * FROM verificar_acesso('172.16.10.25'::INET);    -- TRUE (VPN)

-- Verifica√ß√£o alternativa sem fun√ß√£o
SELECT 
    '10.5.1.100'::INET AS ip,
    CASE 
        WHEN EXISTS(SELECT 1 FROM whitelist WHERE '10.5.1.100'::INET << range_ips)
        THEN 'PERMITIDO ‚úÖ'
        ELSE 'BLOQUEADO ‚ùå'
    END AS status;
```

---

## Exerc√≠cio 7: Operadores de Rede

```sql
-- Setup (j√° fornecido no exerc√≠cio)
CREATE TABLE dispositivos (
    id SERIAL PRIMARY KEY,
    nome TEXT,
    ip INET,
    rede CIDR
);

INSERT INTO dispositivos VALUES
(1, 'Servidor Web', '192.168.1.100', '192.168.1.0/24'),
(2, 'Servidor DB', '192.168.1.200', '192.168.1.0/24'),
(3, 'Firewall', '10.0.0.1', '10.0.0.0/8'),
(4, 'Roteador Principal', '172.16.0.1', '172.16.0.0/12');

-- a) Dispositivos cuja rede cont√©m IP 192.168.1.150
SELECT nome, rede
FROM dispositivos
WHERE '192.168.1.150'::INET << rede;

-- b) Dispositivos na mesma sub-rede que 192.168.1.100
SELECT d1.nome AS dispositivo, d2.nome AS mesmo_subnet_que
FROM dispositivos d1
CROSS JOIN dispositivos d2
WHERE d1.id != d2.id
  AND d1.rede = d2.rede
  AND d2.nome = 'Servidor Web';

-- Alternativa mais simples
SELECT nome, rede
FROM dispositivos
WHERE rede = (SELECT rede FROM dispositivos WHERE ip = '192.168.1.100');

-- c) Endere√ßo de broadcast de cada rede
SELECT 
    nome,
    rede,
    BROADCAST(rede) AS endereco_broadcast,
    NETWORK(rede) AS endereco_rede,
    MASKLEN(rede) AS mascara
FROM dispositivos;

-- d) Verificar overlap entre redes
SELECT 
    '192.168.1.0/24'::CIDR && '192.168.2.0/24'::CIDR AS tem_overlap_1,
    '192.168.1.0/24'::CIDR && '192.168.1.0/25'::CIDR AS tem_overlap_2,
    '10.0.0.0/8'::CIDR && '172.16.0.0/12'::CIDR AS tem_overlap_3;

/*
RESULTADO:
tem_overlap_1 | tem_overlap_2 | tem_overlap_3
--------------|---------------|---------------
false         | true          | false

EXPLICA√á√ÉO:
- && retorna TRUE se as redes t√™m interse√ß√£o
- 192.168.1.0/24 e 192.168.2.0/24 s√£o redes diferentes
- 192.168.1.0/25 est√° contida em 192.168.1.0/24
*/
```

---

## Exerc√≠cio 8: MONEY vs NUMERIC

```sql
-- a) Criar tabelas
CREATE TABLE vendas_money (
    id SERIAL PRIMARY KEY,
    produto VARCHAR(100),
    preco MONEY
);

CREATE TABLE vendas_numeric (
    id SERIAL PRIMARY KEY,
    produto VARCHAR(100),
    preco NUMERIC(10, 2)
);

-- b) Inserir mesmos produtos
INSERT INTO vendas_money (produto, preco) VALUES
('Notebook', 3500.00),
('Mouse', 50.50),
('Teclado', 125.99),
('Monitor', 890.00),
('Webcam', 245.50);

INSERT INTO vendas_numeric (produto, preco) VALUES
('Notebook', 3500.00),
('Mouse', 50.50),
('Teclado', 125.99),
('Monitor', 890.00),
('Webcam', 245.50);

-- c) Calcular desconto de 15%
SELECT 
    produto,
    preco AS preco_original,
    preco * 0.85 AS preco_com_desconto
FROM vendas_money;

SELECT 
    produto,
    preco AS preco_original,
    ROUND(preco * 0.85, 2) AS preco_com_desconto
FROM vendas_numeric;

-- d) Convers√µes
SELECT 
    produto,
    preco AS money_original,
    preco::NUMERIC AS convertido_para_numeric,
    preco::NUMERIC::TEXT AS como_texto
FROM vendas_money;

SELECT 
    produto,
    preco AS numeric_original,
    preco::MONEY AS convertido_para_money
FROM vendas_numeric;

-- e) Teste de performance (opcional)
-- Inserir 10.000 registros
DO $$
BEGIN
    FOR i IN 1..10000 LOOP
        INSERT INTO vendas_money (produto, preco) 
        VALUES ('Produto ' || i, (random() * 1000)::NUMERIC);
        
        INSERT INTO vendas_numeric (produto, preco) 
        VALUES ('Produto ' || i, ROUND((random() * 1000)::NUMERIC, 2));
    END LOOP;
END $$;

-- Comparar tamanho
SELECT 
    'vendas_money' AS tabela,
    pg_size_pretty(pg_total_relation_size('vendas_money')) AS tamanho
UNION ALL
SELECT 
    'vendas_numeric',
    pg_size_pretty(pg_total_relation_size('vendas_numeric'));

/*
CONCLUS√ïES:
- MONEY √© mais compacto mas depende de locale
- NUMERIC √© mais port√°vel e preciso
- Para produ√ß√£o, prefira NUMERIC para valores monet√°rios
*/
```

---

---

## Exerc√≠cio 9: BOOLEAN - Sistema de Tarefas

```sql
CREATE TABLE tarefas_projeto (
    id SERIAL PRIMARY KEY,
    titulo TEXT,
    concluida BOOLEAN DEFAULT FALSE,
    urgente BOOLEAN DEFAULT FALSE,
    aprovada BOOLEAN DEFAULT NULL,
    arquivada BOOLEAN DEFAULT FALSE
);

INSERT INTO tarefas_projeto (titulo, concluida, urgente, aprovada, arquivada) VALUES
('Implementar login', FALSE, TRUE, NULL, FALSE),
('Corrigir bug cr√≠tico', FALSE, TRUE, TRUE, FALSE),
('Refatorar c√≥digo', FALSE, FALSE, NULL, FALSE),
('Atualizar docs', TRUE, FALSE, FALSE, FALSE),
('Code review', TRUE, FALSE, TRUE, FALSE),
('Deploy produ√ß√£o', FALSE, TRUE, FALSE, FALSE),
('Testes unit√°rios', TRUE, TRUE, TRUE, FALSE),
('Reuni√£o cliente', TRUE, FALSE, TRUE, TRUE),
('Backup database', FALSE, FALSE, TRUE, FALSE),
('An√°lise performance', FALSE, FALSE, NULL, FALSE);

-- b) Tarefas pendentes
SELECT * FROM tarefas_projeto
WHERE NOT concluida AND NOT arquivada;

-- c) Tarefas urgentes aguardando aprova√ß√£o
SELECT * FROM tarefas_projeto
WHERE urgente AND aprovada IS NULL;

-- d) Tarefas conclu√≠das mas n√£o aprovadas
SELECT * FROM tarefas_projeto
WHERE concluida AND aprovada = FALSE;

-- e) View de classifica√ß√£o
CREATE VIEW vw_status_tarefas AS
SELECT 
    id,
    titulo,
    CASE
        WHEN arquivada THEN 'üì¶ Arquivada'
        WHEN concluida AND aprovada THEN '‚úÖ Conclu√≠da e Aprovada'
        WHEN concluida AND NOT COALESCE(aprovada, TRUE) THEN '‚ö†Ô∏è  Conclu√≠da mas Reprovada'
        WHEN concluida AND aprovada IS NULL THEN 'üîÑ Aguardando Aprova√ß√£o'
        WHEN urgente AND NOT concluida THEN 'üö® Urgente'
        ELSE 'üìã Pendente'
    END AS status
FROM tarefas_projeto;

SELECT * FROM vw_status_tarefas;
```

### Exerc√≠cio 10: UUID em Sistemas Distribu√≠dos

```sql
CREATE TABLE pedidos (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    servidor_origem VARCHAR(20),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    valor NUMERIC(10,2)
);

-- Simular 3 servidores inserindo simultaneamente
-- (em produ√ß√£o, seriam conex√µes diferentes)
INSERT INTO pedidos (servidor_origem, valor) VALUES ('Servidor-A', 100.00);
INSERT INTO pedidos (servidor_origem, valor) VALUES ('Servidor-B', 150.00);
INSERT INTO pedidos (servidor_origem, valor) VALUES ('Servidor-C', 200.00);
INSERT INTO pedidos (servidor_origem, valor) VALUES ('Servidor-A', 120.00);
INSERT INTO pedidos (servidor_origem, valor) VALUES ('Servidor-B', 175.00);

-- Verificar: todos os IDs s√£o √∫nicos!
SELECT id, servidor_origem, valor FROM pedidos;

-- Compara√ß√£o com SERIAL (problema)
CREATE TABLE pedidos_serial (
    id SERIAL PRIMARY KEY,
    servidor_origem VARCHAR(20),
    valor NUMERIC(10,2)
);

-- Se 3 servidores gerarem IDs localmente, haver√° conflito ao mesclar!
-- Com UUID, n√£o h√° conflito mesmo em sistemas totalmente distribu√≠dos
```

---

## Exerc√≠cio 11: Formata√ß√£o de Datas

```sql
CREATE TABLE relatorio_vendas (
    id SERIAL PRIMARY KEY,
    produto TEXT,
    valor NUMERIC(10,2),
    data_venda TIMESTAMPTZ
);

-- Inserir dados de exemplo
INSERT INTO relatorio_vendas (produto, valor, data_venda) VALUES
('Notebook', 3500.00, '2025-01-15 10:30:00-03'),
('Mouse', 50.00, '2025-02-20 14:15:00-03'),
('Teclado', 200.00, '2025-03-10 09:00:00-03'),
('Monitor', 800.00, '2025-06-25 16:45:00-03'),
('Webcam', 300.00, '2025-09-05 11:20:00-03');

-- Gerar relat√≥rio formatado
SELECT 
    produto,
    valor,
    -- a) Data em formato brasileiro
    TO_CHAR(data_venda, 'DD/MM/YYYY') AS data_br,
    
    -- b) Nome do m√™s por extenso
    TO_CHAR(data_venda, 'TMMonth') AS mes_extenso,
    
    -- c) Dia da semana por extenso
    TO_CHAR(data_venda, 'TMDay') AS dia_semana,
    
    -- d) Trimestre do ano
    'Q' || EXTRACT(QUARTER FROM data_venda) AS trimestre,
    
    -- e) Semana do ano
    EXTRACT(WEEK FROM data_venda) AS semana_ano
FROM relatorio_vendas
ORDER BY data_venda;

-- Relat√≥rio agrupado por m√™s
SELECT 
    TO_CHAR(data_venda, 'YYYY-MM') AS mes,
    TO_CHAR(data_venda, 'TMMonth/YYYY') AS mes_extenso,
    COUNT(*) AS quantidade_vendas,
    SUM(valor) AS valor_total
FROM relatorio_vendas
GROUP BY mes, mes_extenso
ORDER BY mes;
```

---

## Exerc√≠cio 12: MAC Address

```sql
CREATE TABLE dispositivos_rede (
    id SERIAL PRIMARY KEY,
    nome TEXT,
    mac MACADDR,
    ip INET,
    primeira_conexao TIMESTAMPTZ DEFAULT NOW()
);

-- a) Inserir com diferentes formatos
INSERT INTO dispositivos_rede (nome, mac, ip) VALUES
('Servidor Web', '08:00:2b:01:02:03', '192.168.1.100'),
('Firewall', '08-00-2b-01-02-04', '192.168.1.1'),
('Switch Core', '08002b010205', '192.168.1.2'),
('Router', '08:00:2b:01:02:06', '192.168.1.254'),
('Access Point', '08-00-2B-01-02-07', '192.168.1.50');

-- b) Padronizar MACs para formato com h√≠fen
SELECT 
    nome,
    mac,
    REPLACE(mac::TEXT, ':', '-') AS mac_padronizado
FROM dispositivos_rede;

-- c) Identificar fabricante pelo OUI (primeiros 3 bytes)
SELECT 
    nome,
    mac,
    SUBSTRING(mac::TEXT, 1, 8) AS oui,
    CASE SUBSTRING(mac::TEXT, 1, 8)
        WHEN '08:00:2b' THEN 'Digital Equipment Corporation'
        ELSE 'Desconhecido'
    END AS fabricante
FROM dispositivos_rede;

-- d) Dispositivos conectados nas √∫ltimas 24h
SELECT 
    nome,
    mac,
    ip,
    primeira_conexao,
    AGE(NOW(), primeira_conexao) AS tempo_conectado
FROM dispositivos_rede
WHERE primeira_conexao >= NOW() - INTERVAL '24 hours'
ORDER BY primeira_conexao DESC;
```

---

## Exerc√≠cio 13: Queries Complexas com Data/Hora

```sql
CREATE TABLE log_acesso (
    id BIGSERIAL PRIMARY KEY,
    usuario_id INT,
    acao TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- a) Inserir 20 logs distribu√≠dos
INSERT INTO log_acesso (usuario_id, acao, timestamp) VALUES
(1, 'login', NOW() - INTERVAL '5 days' - INTERVAL '2 hours'),
(1, 'view_page', NOW() - INTERVAL '5 days' - INTERVAL '1 hour'),
(2, 'login', NOW() - INTERVAL '4 days' - INTERVAL '3 hours'),
(1, 'logout', NOW() - INTERVAL '4 days'),
(3, 'login', NOW() - INTERVAL '3 days' - INTERVAL '5 hours'),
(2, 'view_page', NOW() - INTERVAL '3 days' - INTERVAL '4 hours'),
(3, 'logout', NOW() - INTERVAL '3 days' - INTERVAL '3 hours'),
(1, 'login', NOW() - INTERVAL '2 days' - INTERVAL '6 hours'),
(2, 'login', NOW() - INTERVAL '2 days' - INTERVAL '2 hours'),
(1, 'view_page', NOW() - INTERVAL '2 days'),
(3, 'login', NOW() - INTERVAL '1 day' - INTERVAL '8 hours'),
(2, 'logout', NOW() - INTERVAL '1 day' - INTERVAL '6 hours'),
(1, 'login', NOW() - INTERVAL '1 day' - INTERVAL '3 hours'),
(3, 'view_page', NOW() - INTERVAL '12 hours'),
(2, 'login', NOW() - INTERVAL '10 hours'),
(1, 'logout', NOW() - INTERVAL '8 hours'),
(3, 'login', NOW() - INTERVAL '6 hours'),
(2, 'view_page', NOW() - INTERVAL '4 hours'),
(1, 'login', NOW() - INTERVAL '2 hours'),
(3, 'logout', NOW() - INTERVAL '1 hour');

-- b) Acessos por hora do dia
SELECT 
    EXTRACT(HOUR FROM timestamp) AS hora,
    COUNT(*) AS quantidade_acessos
FROM log_acesso
GROUP BY hora
ORDER BY hora;

-- c) Acessos por dia da semana
SELECT 
    TO_CHAR(timestamp, 'TMDay') AS dia_semana,
    EXTRACT(DOW FROM timestamp) AS dia_num,
    COUNT(*) AS quantidade_acessos
FROM log_acesso
GROUP BY dia_semana, dia_num
ORDER BY dia_num;

-- d) Hor√°rio de pico
SELECT 
    EXTRACT(HOUR FROM timestamp) AS hora_pico,
    COUNT(*) AS acessos
FROM log_acesso
GROUP BY hora_pico
ORDER BY acessos DESC
LIMIT 1;

-- e) M√©dia de acessos por usu√°rio por dia
SELECT 
    usuario_id,
    DATE(timestamp) AS dia,
    COUNT(*) AS acessos_dia,
    AVG(COUNT(*)) OVER (PARTITION BY usuario_id) AS media_por_dia
FROM log_acesso
GROUP BY usuario_id, dia
ORDER BY usuario_id, dia;
```

---

## Exerc√≠cio 14: Tipo DOMAIN Customizado

```sql
-- a) DOMAIN para email
CREATE DOMAIN email AS TEXT
    CHECK (VALUE ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
    NOT NULL;

COMMENT ON DOMAIN email IS 
    'Email validado com regex. Formato: usuario@dominio.ext';

-- b) DOMAIN para telefone brasileiro
CREATE DOMAIN telefone_br AS VARCHAR(15)
    CHECK (VALUE ~ '^\(\d{2}\) \d{4,5}-\d{4}$');

-- c) DOMAIN para CPF (apenas d√≠gitos)
CREATE DOMAIN cpf AS CHAR(11)
    CHECK (VALUE ~ '^\d{11}$');

-- d) DOMAIN para valor positivo
CREATE DOMAIN valor_positivo AS NUMERIC(10,2)
    CHECK (VALUE > 0);

-- Usar os DOMAINs
CREATE TABLE clientes_validados (
    id SERIAL PRIMARY KEY,
    nome TEXT NOT NULL,
    email email,
    telefone telefone_br,
    cpf cpf UNIQUE,
    credito valor_positivo DEFAULT 0.01
);

-- Teste: Inser√ß√£o v√°lida
INSERT INTO clientes_validados (nome, email, telefone, cpf, credito) VALUES
('Jo√£o Silva', 'joao@email.com', '(11) 98765-4321', '12345678901', 1000.00);

-- Teste: Email inv√°lido
INSERT INTO clientes_validados (nome, email) VALUES
('Maria', 'email-sem-arroba');
-- ERROR: value for domain email violates check constraint

-- Teste: CPF com formata√ß√£o
INSERT INTO clientes_validados (nome, email, cpf) VALUES
('Pedro', 'pedro@email.com', '123.456.789-00');
-- ERROR: apenas d√≠gitos permitidos
```

---

## Exerc√≠cio 15: IPv6

```sql
CREATE TABLE dispositivos_ipv6 (
    id SERIAL PRIMARY KEY,
    nome TEXT,
    ipv6 INET,
    rede_ipv6 CIDR
);

-- a) Inserir dispositivos com IPv6
INSERT INTO dispositivos_ipv6 (nome, ipv6, rede_ipv6) VALUES
('Servidor Principal', '2001:db8::1', '2001:db8::/32'),
('Servidor Backup', '2001:db8::2', '2001:db8::/32'),
('Firewall', 'fe80::1', 'fe80::/10'),  -- Link-local
('Router', '2001:db8:1::1', '2001:db8:1::/48');

-- b) Verificar se IPv6 est√° na rede
SELECT nome FROM dispositivos_ipv6
WHERE '2001:db8::5'::INET << rede_ipv6;

-- c) Nota√ß√µes (PostgreSQL normaliza automaticamente)
SELECT 
    nome,
    ipv6,
    HOST(ipv6) AS ipv6_completo,
    MASKLEN(rede_ipv6) AS mascara
FROM dispositivos_ipv6;

-- d) Identificar tipo de endere√ßo
SELECT 
    nome,
    ipv6,
    CASE 
        WHEN ipv6 << 'fe80::/10'::CIDR THEN 'Link-Local'
        WHEN ipv6 << 'fc00::/7'::CIDR THEN 'Unique Local'
        WHEN ipv6 << '2000::/3'::CIDR THEN 'Global Unicast'
        WHEN ipv6 << '::1/128'::CIDR THEN 'Loopback'
        ELSE 'Outro'
    END AS tipo_endereco
FROM dispositivos_ipv6;
```

---

## Exerc√≠cio 16: Compara√ß√£o de Performance

```sql
-- Criar tabelas
CREATE TABLE tabela_int (
    id INT PRIMARY KEY,
    dados TEXT
);

CREATE TABLE tabela_bigint (
    id BIGINT PRIMARY KEY,
    dados TEXT
);

CREATE TABLE tabela_uuid (
    id UUID PRIMARY KEY,
    dados TEXT
);

-- Inserir 100.000 registros
INSERT INTO tabela_int 
SELECT i, 'dados_' || i 
FROM generate_series(1, 100000) i;

INSERT INTO tabela_bigint 
SELECT i, 'dados_' || i 
FROM generate_series(1, 100000) i;

INSERT INTO tabela_uuid 
SELECT gen_random_uuid(), 'dados_' || i 
FROM generate_series(1, 100000) i;

-- Comparar tamanho em disco
SELECT 
    'tabela_int' AS tabela,
    pg_size_pretty(pg_total_relation_size('tabela_int')) AS tamanho
UNION ALL
SELECT 
    'tabela_bigint',
    pg_size_pretty(pg_total_relation_size('tabela_bigint'))
UNION ALL
SELECT 
    'tabela_uuid',
    pg_size_pretty(pg_total_relation_size('tabela_uuid'));

-- Comparar tempo de SELECT por PK (execute v√°rias vezes)
EXPLAIN ANALYZE 
SELECT * FROM tabela_int WHERE id = 50000;

EXPLAIN ANALYZE 
SELECT * FROM tabela_bigint WHERE id = 50000;

EXPLAIN ANALYZE 
SELECT * FROM tabela_uuid WHERE id = (SELECT id FROM tabela_uuid LIMIT 1);

/*
RESULTADOS ESPERADOS:
- INT: Menor tamanho (4 bytes/PK)
- BIGINT: Tamanho m√©dio (8 bytes/PK)
- UUID: Maior tamanho (16 bytes/PK)
- Performance de SELECT por PK: Similar para todos (√≠ndice B-tree)
- JOIN: INT/BIGINT mais r√°pidos que UUID
*/
```

---

## Exerc√≠cio 17: Opera√ß√µes Avan√ßadas com INTERVAL

```sql
-- a) Calcular idade exata
CREATE FUNCTION calcular_idade_exata(data_nascimento DATE)
RETURNS TEXT AS $$
DECLARE
    idade_interval INTERVAL;
    anos INT;
    meses INT;
    dias INT;
BEGIN
    idade_interval := AGE(CURRENT_DATE, data_nascimento);
    anos := EXTRACT(YEAR FROM idade_interval);
    meses := EXTRACT(MONTH FROM idade_interval);
    dias := EXTRACT(DAY FROM idade_interval);
    
    RETURN anos || ' anos, ' || meses || ' meses e ' || dias || ' dias';
END;
$$ LANGUAGE plpgsql;

SELECT calcular_idade_exata('1990-05-15');

-- b) Fun√ß√£o de tempo relativo
CREATE FUNCTION tempo_relativo(timestamp_passado TIMESTAMPTZ)
RETURNS TEXT AS $$
DECLARE
    diff INTERVAL;
    segundos BIGINT;
BEGIN
    diff := NOW() - timestamp_passado;
    segundos := EXTRACT(EPOCH FROM diff)::BIGINT;
    
    IF segundos < 60 THEN
        RETURN 'h√° ' || segundos || ' segundos';
    ELSIF segundos < 3600 THEN
        RETURN 'h√° ' || (segundos / 60) || ' minutos';
    ELSIF segundos < 86400 THEN
        RETURN 'h√° ' || (segundos / 3600) || ' horas';
    ELSIF segundos < 604800 THEN
        RETURN 'h√° ' || (segundos / 86400) || ' dias';
    ELSIF segundos < 2592000 THEN
        RETURN 'h√° ' || (segundos / 604800) || ' semanas';
    ELSE
        RETURN 'h√° ' || (segundos / 2592000) || ' meses';
    END IF;
END;
$$ LANGUAGE plpgsql;

SELECT tempo_relativo(NOW() - INTERVAL '2 days 3 hours');

-- c) Pr√≥ximo feriado
CREATE TABLE feriados (
    data DATE PRIMARY KEY,
    nome TEXT
);

INSERT INTO feriados VALUES
('2025-12-25', 'Natal'),
('2026-01-01', 'Ano Novo'),
('2026-04-21', 'Tiradentes');

SELECT 
    nome,
    data,
    data - CURRENT_DATE AS dias_faltando
FROM feriados
WHERE data > CURRENT_DATE
ORDER BY data
LIMIT 1;
```

---

## Exerc√≠cio 18: Migra√ß√£o de Tipos

```sql
-- Tabela legada
CREATE TABLE legado (
    id INT,
    data_criacao VARCHAR(20),  -- 'DD/MM/YYYY HH24:MI'
    valor VARCHAR(20),         -- 'R$ 1.234,56'
    ip_cliente VARCHAR(50)
);

-- Inserir dados de teste
INSERT INTO legado VALUES
(1, '15/11/2025 10:30', 'R$ 1.234,56', '192.168.1.100'),
(2, '16/11/2025 14:45', 'R$ 500,00', '10.0.0.50'),
(3, '17/11/2025 09:15', 'R$ 2.500,75', 'ip-invalido'),  -- Erro proposital
(4, '18/11/2025 16:00', 'R$ 999,99', '172.16.0.1');

-- a) Criar tabela nova com tipos corretos
CREATE TABLE novo (
    id INT PRIMARY KEY,
    data_criacao TIMESTAMPTZ,
    valor NUMERIC(10,2),
    ip_cliente INET
);

-- b) Script de migra√ß√£o com tratamento de erros
DO $$
DECLARE
    rec RECORD;
    valor_limpo TEXT;
BEGIN
    FOR rec IN SELECT * FROM legado LOOP
        BEGIN
            -- Limpar valor monet√°rio
            valor_limpo := REPLACE(REPLACE(rec.valor, 'R$ ', ''), '.', '');
            valor_limpo := REPLACE(valor_limpo, ',', '.');
            
            INSERT INTO novo (id, data_criacao, valor, ip_cliente) VALUES (
                rec.id,
                TO_TIMESTAMP(rec.data_criacao, 'DD/MM/YYYY HH24:MI'),
                valor_limpo::NUMERIC,
                rec.ip_cliente::INET
            );
            
            RAISE NOTICE 'Migrado ID %: OK', rec.id;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING 'Erro ao migrar ID %: %', rec.id, SQLERRM;
        END;
    END LOOP;
END $$;

-- c) Validar migra√ß√£o
SELECT COUNT(*) AS total_legado FROM legado;
SELECT COUNT(*) AS total_migrado FROM novo;
SELECT * FROM novo ORDER BY id;
```

---

## Exerc√≠cio 19 e 20: Dispon√≠veis nos arquivos de li√ß√µes

Para os exerc√≠cios 19 (Sistema de Logs) e 20 (Desafio Final), consulte os arquivos de li√ß√µes que cobrem todos os t√≥picos necess√°rios:

- [JSONB e Dados Semi-Estruturados](./02-jsonb-dados-semi-estruturados.md)
- [Arrays e Tipos Compostos](./03-arrays-tipos-compostos.md)
- [Tipos Customizados](./05-tipos-customizados.md)

---

## üîó Navega√ß√£o

[‚Üê Voltar para Exerc√≠cios](./exercicios.md) | [√çndice do M√≥dulo](./README.md)
